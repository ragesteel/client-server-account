Набрёл на просьбу о помощи в форуме http://javatalks.ru/topics/41651
Хоть оно размещено не в разделе «Сделайте за меня», но самое задание меня как-то зацепило. С одной стороны — довольно простое, с другой — интресно «поиграть в кубики», т.е. поиграть с технологиями, вариантами решений.

Оригинальный текст сообщения:
---
одскажите, пожалуйста, несколько моментов по реализации программы.

По условию задачи, нужно создать сервис с интерфейсом:

Quote:
1.
public interface AccountService {
	/**
	 * Возвращает текущий баланс или 0 если addAmount() не был вызван перед этим для заданного id.
	 */
	Long getAmount(Integer id);

	/**
	 * Увеличивает баланс или устанавливает его, если addAmount() вызывается в первый раз 
	 * Increases balance or set if addAmount() method was called first time
	 */
	void addAmount(Integer id, Long value);
}

Сервис должен кешировать данные в памяти и сохранять данные в БД(PostgreSQL, MySQL).
В качестве транспортного слоя можно выбрать любой из протоколов RMI, Hessian, HTTP.

2. Создать тестового клиента

Тестовый клиент должен уметь запускать несколько конкурентных потоков на определённом подмножестве идентификаторов
Параметры для тестового клиента
- rCount - количество читателей вызывающих метод getAmount(id)
- wCount - количество читателей вызывающих метод addAmount(id, value)

Одновременно можно запускать несколько тестовых клиентов на одном или разных компьютерах.


Я не понимаю несколько моментов:

1. Если я работаю intellij idea, мне нужно создавать 2 проекта: в первом проекте будет реализован сервер, во втором - клиент?
2. Сервис с интерфейсом. То есть я определяю эти 2 интерфейса, а потом делаю их реализацию в классе/классах? Не понимаю назначения и использования интерфейсов в этой программе.
3. Как организовать кеширование сервером данных и сохранение их в БД? Мне нужно предварительно скачать БД(Например, MySQL), установить её, а потом к ней обращаться?
При этом это все будет в коде сервера и сервер будет работать в одном потоке?

Что использовать, чтоб написать серверный код? Сокеты? Классы, которые будут использоваться для прослушки запросов от клиента?

4. Вопросы по клиенту. Один клиент будет вызывать несколько потоков, в каждом из которых будет работать метод getAmount(id) или addAmount(id,value) со своим id. При этом я так понимаю нужно организовать, чтоб можно было читать нескольким потоком( в это время писать нельзя), а писать одному потоку(при этом читать нельзя).
И в чем будет особенность, когда будет запускать несколько клиентов.
---

Ответы на вопросы автора:
1. Т.к. я избалован maven'ом и без него мне грусно — использую его. У меня будет четыре проекта: корневой, api, client и server.
2. Два интерфейса я не нашёл, автор привёл только один. Возможно имелось ввиду то, что у этого интерфейса два метода. Отвечать на вопрос зачем вообще интерфейсы нужны — не интересно, хочется быстрей чего-нибудь покодить.
3. До кэширования я ещё дойду, а работа с базой видимо будет через JDBC. Нужно или установить базу данных себе локально, либо найти какой-нибудь хостинг, который предоставляет базу данных.
И да, всё будем строить с учётом многопоточной обработки.
Для реализации сервера я буду использовать какой-нибудь Servlet-контейнер, вроде Tomcat или Jetty. Там уже слушанье клиента реализовано.
4. Никаких ограничений на возможность параллельного чтения/записи у нас в условии не содержатся, значит и их и не будет.

== Начальные допущения ==

В качестве базы возьмём Apache Derby, чтобы не возится с сервером MySQL/PostgreSQL.
Ещё у нас не определено, что делать, если в переданных параметрах встречается null. Я решил, что это должно вызывать исключение.
Проверку на переполнения значения делать не будем, чтобы не усложнять.
На знак чисел не обращаем внимания, т.е. у нас вполне может быть отрицательные счета и добавление отрицательных значений.
Кэш прикрутим потом, ибо сначала нужно сделать чтобы работало, потом — чтобы работало правильно, и наконец — чтобы работало быстро. А кэш, это про то, чтобы работало быстро. Поэтому его мы и отложим на потом. Но так как у нас сервис занимается аккаунтами, то можно предположить, что тут будет важна надёжность, поэтому кэш у нас будет только на чтение.

== Выбор инструментов и обоснование ==

Java 7: не 6, ибо ARM уж очень упрощает жизнь.
Lombok: возможность писать меньше однообразного кода.
Apache Derby: embeddedable-база, которую я взял за возможность не поднимать отдельный сервер. Да, есть ещё h2, но с derby у меня уже есть некоторый опыт.
Liquibase: штука, которой я доверяю автоматическое создание/обновление структуры таблиц.
Apache Tomcat: простой Servlet-контейнер.

== Установка ==
В lib Tomcat'а добавлен derby.jar.

Версии компонентов, использованные при разработке:
JRE 1.7.0_55
Tomcat 7.0.53
Derby 10.10.2.0

== Журнал разработки ==

=== 2014-04-16 23:39 MSK ===

Болванки pom.xml создал, теперь нужно поставить git, чтобы сделать первый коммит заготовок.

=== 2014-04-16 23:51 MSK ===

Пока тут качаются новые версии Java и GIT'а опишу то, что я хочу сделать.
Слушать соединения будет Servlet'ам(и). Или один для двух методов или отдельный на каждый метод интерфейса. У нас будет что-то вроде REST'а.
По GET запросу на /accountService/идентификатор будем возвращать значение счётчика.
А по PUT запросу на /accountService/идентфикатор увеличиваем значение счётчик на value, которое содержится в запросе.

Сначала сделаем без какого-либо кэша — всё через базу данных.
Логика запроса на чтение: делаем SELECT value FROM account WHERE id = ?, если в ответе пустой запрос — возвращаем ноль, иначе — значение value.
Запрос на запись будет выглядеть так:
 * начинаем транзакцию;
 * выполняем UPDATE TABLE account SET value = value + ? WHERE id = ?;
 * если счётчик обновлённых рядов равен нулю, то значит такого баланса ещё нет — добавляем его с помощью INSERT INTO TABLE account (id, value) VALUES (?, ?);
 * делаем commit транзакции, если не получилось из-за паралельной модификации в другой транзакции — то повторяем;

Для проверки добавим в сервер паузу после вызова UPDATE и запустим несколько параллельных записей в таблицу, в итоге, после завершения всех поток нужно получить общую сумму добавленных значений.

=== 2014-04-17 01:05 MSK ===

Вот, пока и всё на сегодня. Спать пора всё-таки!

=== 2014-04-17 07:59 MSK ===

Наиваная реализация готова, теперь нужно научиться правильно обрабатывать исключения, которые возникнут при параллельном обновлении, поэтому самое время написать немного тестов. А перед этим — добавить Liquibase для создания структуры таблиц, ибо тест у меня будет работать с базой в памяти и я не хочу засорять код всякими там CREATE TABLE.

=== 2014-04-17 09:47 MSK ===

В обычном режими потестировали, теперь нужно проверить всё это в многопоточном режиме и сделать так что оно и этом случае корректно работало. Для ускорения обнаружения проблем — добавим паузу перед commit'ом транзакции.

=== 2014-04-17 10:21 MSK ===

Вот я делаю сначала UPDATE а затем INSERT с обработкой исключений, а в некоторых базах и этого не нужно, ибо в MySQL есть INSERT ... ON DUPLICATE KEY UPDATE.

=== 2014-04-17 20:03 MSK ===

Теперь когда готовы внутренности, нужно доделать Servlet, добавить разбор параметров, сконфигурировать web-приложение, чтобы работало подключение к базе данных, а потом сделать клиента.

=== 2014-04-17 23:02 MSK ===

Наконец-то заработало подключение базы данных в Tomcat'е.

=== 2014-04-18 08:30 MSK ===

Раз всё теперь так замечательно работает, значит самое время переходить к многопоточному клиенту. И хочется не просто сделать нечто, что запускается из коммандной строки, а написать некий GUI, естественно на JavaFX. Ведь так здорово будет визуализировать выполнение запросов.

Итак у нас есть следующие входные данные для клиента:

Адрес подключения к серверу (чтобы можно было указать не только localhost и запускать на разных компьютерах).
Верхняя и нижняя границы диапазона идентификаторов — пусть будут просто поля ввода для чисел.
Количество читателей, которые вызывают getAmount(id).
Количество писателей, которые вызывают addAmount(id, value).
Добавляемое значение.

В интерфейсе это можно отобразить таким образом:

Поля ввода:
* адрес;
* верхняя и нижняя граница диапазона идентификаторов;
* количество читателей и писателей — числовые поля плюс слайдеры;
* добавляемое значение;

Кнопки Start / Stop для запуска/остановки запросов.
Счётчики количества чтений, количества записей и соответствующих скоростей (запросов в секунду).

Также хочется какого-нибудь action'а, чтобы график какой-нибудь бежал, т.к. у меня нет опыта с JavaFX'ными графиками, самое время ими заняться.

Хотя, ладно, фиг с ним с графиками. Важней сделать так, чтобы количество читателей/писателей можно было менять без перезапуска.
Для читателей и писателей заведём отдельные ThreadPool'ы. Посмотрим, есть-ли какая-нибудь реализация, в которой можно менять количество потоков на лету.

Видимо нужно пойти с другой стороны — пронумеровать задачи и хранить целевое количество подключений. Между запросами проверять, нужен ли дальше выполняться (у задачи номер меньше целевого количества), если не нужно — выходим.

=== 2014-04-18 13:14 MSK ===

=== 2014-04-18 17:10 MSK ===

Всё-таки у нас будет два pool'а, чтобы было удобней считать количество запущенных задач.

=== 2014-04-19 21:08 MSK ===

Нужно определиться с подходом к увеличению/уменьшению количества задач.
Можно добавить флаг, при установке которого нужно проверять условие на продолжение.
Этот флаг будет выставляться, когда нужно уменьшить количество потоков.

=== 2014-04-19 21:36 MSK ===

Готово, теперь дело за графическим интерфейсом. Просто накидаем, а потом разберёмся.
